# Архитектура клиента wb-mqtt-alice

Архитектура решения строится на следующих принципах:

1. **Data Flow (потоковая обработка данных)**
   Так как сама интеграция по своей сути является именно потоком данных\
   из одной системы в другие и попытки создания сложного, но удобного объекта\
   девайса преврашает его в god object который сложно тестировать.\
   Приложение сознательно НЕ моделирует устройства как сложные объекты\
   с поведением (OOP), а рассматривает их как набор данных, проходящих\
   через серию трансформаций.

2. **Single Responsibility Principle (SRP)**
   Разделяет приложение на слабо связанные слои и элементы внутри слоя,\
   которые можно изменять и тестировать отдельно друг от друга.

Система состоит из четырех логических слоев, каждый из которых изолирован
и тестируется независимо.

## Верхнеуровневая структура

Приложение (Application) выступает в роли оркестратора. При запуске
оно загружает конфигурацию, строит неизменяемые реестры (Registry)
и инициализирует функциональные слои.

Основные слои:

- Transport Layer (Downstream & Upstream Adapters)
  Отвечает за физическое соединение с внешним миром (MQTT, HTTP, WebSocket).
  Не содержит бизнес-логики.

- Translation Layer (Bridges & Codecs)
  Нормализует данные. Превращает сырые байты протоколов во внутренние
  типизированные структуры Python и обратно.

- Dispatcher Layer (Business Logic)
  Центральный мозг. Работает только с нормализованными данными. Принимает
  решения о батчинге, хранит текущее состояние.

- Infrastructure (Config & Registry)
  Статические данные, описывающие конфигурацию системы и возможности устройств.

Одна из главных целей - полностью отделить оба транспорта (нижний и верхний)
от логики интеграции. Это позволяет приложению получать события с обеих
сторон (от устройств и от Яндекса), не зная, по какому транспорту они пришли.
А приложение по центру концентрируется конкретно на задачах преобразования,
батчинга и тд.

## Детальное описание компонентов

### 1. Infrastructure & Configuration

Статический слой, формируемый при старте приложения.

- Config Loader: Читает JSON-конфиг.

- DeviceRegistry: Справочник описаний устройств (Capabilities, Properties).
  Это "Read-only" структура. Она знает, что умеет устройство, но не знает
  его текущего состояния. И не содержит методов для работы с девайсами.

- BindingRegistry: Справочник связей (биндингов).
  Хранит карту соответствия: Adapter info (MQTT Topic) <-> Yandex Device ID + Instance.

### 2. Downstream Layer (Связь с оборудованием)

Отвечает за взаимодействие с контроллером Wiren Board через MQTT.

Состав:

- DownstreamAdapter (Transport): Реализует специфику протокола (MQTT).
  Умеет подписываться на топики и публиковать сообщения. Не знает про Яндекс.

- DownstreamBridge: Промежуточный слой адаптации.

- Codec: Преобразует сырые payload (строки "1", "0", JSON) в типы Python.

- BindingResolver (Router): Определяет, какому устройству принадлежит пришедшее сообщение.

- ValueTranslator: Адаптирует значения под специфические форматы яндекса
  учитывая такие тонкости, как ограничения устройства (например, маппинг яркости
  0-255 в 0-100 или инверсия значений).

Цель слоя: Скрыть детали транспорта. Ядро получает уже чистый словарь
`{device_id: "lamp1", capability: "on_off", value: True}`, не зная, пришло
это из MQTT, Modbus или Zigbee.

### 3. Dispatcher Layer (Диспетчер и Состояние)

Здесь живет логика интеграции. Ядро работает изолированно от внешних интерфейсов.

Состав:

- StateStore: Единственный источник истины о текущем состоянии всех устройств.
  Хранит "тень" устройства (Shadow State).
  Позволяет мгновенно отвечать на запросы (query) от Яндекса, не опрашивая физические устройства.
  Используется для фильтрации дублей (если пришло значение, равное текущему — не отправлять уведомление).

- StateManager: Управляет потоками данных.

- Batcher: Накапливает изменения состояний, чтобы отправить их в Яндекс
  одним пакетом (снижение нагрузки на API).

- RateLimiter: Следит за лимитами частоты запросов.

Важно: Мы сознательно отказались от хранения значения value внутри объекта
Device. Объект Device — это описание (схема). StateStore — это данные. Это
упрощает сериализацию и тестирование.

### 4. Upstream Layer (Связь с платформой Яндекс)

Отвечает за общение с облаком Yandex Smart Home.

Состав:

- YandexFormatter: Чистая функция трансформации.
  Преобразует внутренние структуры событий в JSON-формат devices.notifiers.
  Парсит входящие JSON action-запросы в список внутренних команд.
  Позволяет тестировать парсинг гигантских JSON-пакетов локально без сети.

- UpstreamAdapter: Транспорт до Яндекса.
  Поддерживает Cloud (Socket.IO) и Local (HTTP Server) режимы.
  Отвечает за авторизацию и поддержку соединения.

Цель: Application не должен знать, что находится "под капотом", он просто
должен вызвать connect() и получать события, которые приходят откуда-то. Для
этого Upstream Layer вынесен отдельно и его интерфейс унифицирован.

Базовый класс BaseUpstreamAdapter имеет метод connect(), который реализуется
в CloudAdapter и в LocalAdapter разными способами.

## Структура с отражением вложенности элементов

```text
Application (main.py)
  │
  ├─ Config (loaded from JSON)
  │
  ├─ DeviceRegistry (built from config)
  │
  ├─ BindingRegistry (built from config)
  │
  ├─ DownstreamAdapters (MqttAdapter, etc.)
  │
  ├─ DownstreamBridge
  │  ├─ BindingResolver
  │  ├─ ValueTranslator
  │  ├─ DeviceRegistry ← REFERENCE!
  │  └─ Codecs
  │
  ├─ StateManager
  │  ├─ StateStore
  │  ├─ RateLimiter
  │  └─ Batcher
  │
  ├─ YandexFormatter
  │  └─ (No external dependencies, pure function)
  │
  └─ UpstreamAdapters (Yandex Cloud, Local)
     └─ Config ← REFERENCE! (Auth tokens, URLs)
```


1. DownstreamAdapter - часть транспорта
   Предоставляет интерфейс работы с девайсами и знает как кодировать
   и декодировать данные из этого транспорта в формат понятный яндексу.
   Данная часть состоит из двух частей:
    - Адаптер - это отдельная сущность которая содержит только логику
      транспорта, в нашем случае это mqtt в WirenBoard конвенции.
    - Кодек - это правила которыми пользуется система для конвертации данных
      из формата девайсов в формат понятный яндексу и обратно.

   Польза слоя заключается в том что можно подменять источники ядра для тестов,
   а так же теоретически писать кастомные адаптеры не только для MQTT.

DownstreamBridge -отдельная сущность, которая лежит рядом с Adapter и не содержит его


   - Роутер - содержит логику биндинга полученных сырых значених из адаптера
     к конкретному девайсу и его части. Например из топика нужно записать в
     девайс1, а в нем в температуру. Плюс занимается нормализацией данных
     для ядра, чтобы внутри ядра все данные были уже в одном формате.
   - Регистри биндинга - содержит список всех биндингов которые настроил
     пользователь.

2. Pipeline часть
   Содержит всю логику специфичную для яндекса - внутри работает только
   с нормализованными данными которые подготовил кодек. Данная часть\
   состоит из нескольких юнитов:
   - StateStore: Хранилище данных о текущем состоянии всех устрйоств.
     Тут содержатся все состояния умений и свойств девайсов. Это сделано
     сознательно отедльно от девайса чтобы девайс оставался описанием
     и не содержал данных, поэтому внутри девайса решено не делать поле value.
     NOTE: Мы честно пытались сделать интеграцию с яндексом похожей на тупой прокси
     но эта идея не делать внутреннее хранилище уже несколько раз оказывалось
     не правильным решением. Это удобно для быстрых ответов яндексу на query
     запросы, удобно для дедубликации и для логики батчинга, рейт лимитов,
     фильтров по дельте требующих историю и тд.
   - Девайс - сущность содержащая удобное Python представление девайса с
     тем какие у него есть умения, свойства и тд.
   - Регистри девайсов - содержит список всех девайсов.

    Польза слоя заключается в том что можно тестировать ядро отдельно от транспортов.

3. YandexFormatter сознательно отделен от Upstream adapter - чтобы можно было
   тестировать систему подавая на вход нужные json в локальном режиме работы - например как будто яндекс решил нам записать за секунду 1000 mqtt запросов - выдержим ли мы это учитывая парсинг json

4. Upstream часть транспорта
   Предоставляет интерфейс связи нашей локальной системы с умным домом яндекса.

   Польза слоя заключается в том что можно подменять методы связи ядра с яндексом
   для тестов, а так же теоретически писать локальную реализацию вместо облачной,
   заменить при необходимости Socket.IO на что то другое.

Верхний уровень называется Application - он склеивает все слои вместе

```
class Application:
    """
    Top-level orchestrator
    
    Owns все слои и склеивает их
    """
    
    # === Layer 1: Transport ===
    mqtt_adapter: MQTTAdapter
    socketio_adapter: SocketIOAdapter
    
    # === Layer 2: Translation ===
    downstream_bridge: DownstreamBridge
    upstream_bridge: UpstreamBridge
    
    # === Layer 3: Core (Business Logic) ===
    core: IntegrationCore
    
    # === Layer 4: Infrastructure ===
    # (создаются в Core, но можно вынести)
    state_store: StateStore
    rate_limiter: RateLimiter
    batcher: Batcher
```
